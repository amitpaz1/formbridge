/**
 * Event Store Interface
 * Provides pluggable storage abstraction for audit trail event streams.
 * Supports in-memory and persistent storage backends.
 */

import type {
  IntakeEvent,
  IntakeEventType,
  Actor,
} from "../types/intake-contract.js";

// =============================================================================
// ยง Event Query Filters
// =============================================================================

/**
 * Filters for querying events from the event store.
 * All filters are optional and can be combined.
 */
export interface EventFilters {
  /** Filter by event types. Empty array or undefined means all types. */
  types?: IntakeEventType[];
  /** Filter by actor kind (agent, human, system). Undefined means all actors. */
  actorKind?: Actor["kind"];
  /** Only events on or after this timestamp (ISO 8601). Inclusive. */
  since?: string;
  /** Only events before or on this timestamp (ISO 8601). Inclusive. */
  until?: string;
  /** Maximum number of events to return. Undefined means no limit. */
  limit?: number;
  /** Number of events to skip before returning results. Defaults to 0. */
  offset?: number;
}

// =============================================================================
// ยง Event Store Statistics
// =============================================================================

/**
 * Statistics about the event store.
 * Useful for monitoring, debugging, and capacity planning.
 */
export interface EventStoreStats {
  /** Total number of events stored across all submissions */
  totalEvents: number;
  /** Number of unique submissions with events */
  submissionCount: number;
  /** Timestamp of the oldest event in the store (ISO 8601) */
  oldestEvent?: string;
  /** Timestamp of the newest event in the store (ISO 8601) */
  newestEvent?: string;
}

// =============================================================================
// ยง Event Store Interface
// =============================================================================

/**
 * Pluggable storage backend for audit trail event streams.
 *
 * Events are append-only and immutable. Once written, they cannot be
 * modified or deleted (except through bulk cleanup operations).
 *
 * Implementations must:
 * 1. Guarantee append-only semantics (events never modified after write)
 * 2. Preserve event order within a submission (ordered by timestamp)
 * 3. Support efficient querying by submission ID
 * 4. Support filtering by event type, actor, and time range
 * 5. Handle concurrent writes safely (multiple events appended simultaneously)
 *
 * Available implementations:
 * - InMemoryEventStore: Development/testing with in-memory storage
 * - (Future) DatabaseEventStore: Production with persistent database storage
 * - (Future) S3EventStore: Archival storage with S3-compatible object storage
 */
export interface EventStore {
  /**
   * Append a new event to the store.
   *
   * Events are immutable once appended. The event must have:
   * - Unique eventId (generated by caller)
   * - Valid submissionId
   * - ISO 8601 timestamp in ts field
   * - Valid event type and actor
   *
   * @param event The event to append
   * @throws If event validation fails (duplicate eventId, invalid format, etc.)
   */
  appendEvent(event: IntakeEvent): Promise<void>;

  /**
   * Get all events for a submission, optionally filtered.
   *
   * Events are returned in chronological order (oldest first).
   * Filters are applied server-side for efficiency.
   *
   * @param submissionId The submission ID to query
   * @param filters Optional filters to narrow results
   * @returns Array of events matching the query (empty if submission not found)
   */
  getEvents(
    submissionId: string,
    filters?: EventFilters
  ): Promise<IntakeEvent[]>;

  /**
   * Get store statistics.
   *
   * Useful for monitoring and capacity planning.
   * Implementation may be approximate for performance reasons.
   *
   * @returns Statistics about the event store
   */
  getStats(): Promise<EventStoreStats>;

  /**
   * Clean up old events for storage maintenance.
   *
   * Removes events older than the specified age.
   * Use with caution - this is the only operation that deletes events.
   *
   * Typical use cases:
   * - Regulatory retention limits (e.g., delete events older than 7 years)
   * - Development/testing cleanup
   * - Storage capacity management
   *
   * @param olderThanMs Age threshold in milliseconds (events older than this are deleted)
   * @returns Number of events deleted
   */
  cleanupOld(olderThanMs: number): Promise<number>;
}

// =============================================================================
// ยง InMemoryEventStore Implementation
// =============================================================================

/**
 * InMemoryEventStore - In-memory storage for development and testing.
 *
 * Implements:
 * - Append-only event storage in memory
 * - Efficient querying by submission ID
 * - Server-side filtering by type, actor, and time range
 * - Statistics calculation
 * - Event cleanup for testing/development
 *
 * Performance characteristics:
 * - Append: O(1)
 * - Query: O(n) where n = events for submission
 * - Filter: O(n) where n = events matching submission
 * - Stats: O(n) where n = total events
 *
 * Storage:
 * - Events are stored in a Map keyed by submissionId
 * - Each submission has an array of events in chronological order
 * - All events are also tracked in a Set for duplicate detection
 *
 * Thread safety:
 * - Safe for concurrent reads
 * - Writes are synchronized (JavaScript single-threaded nature)
 *
 * Limitations:
 * - Data is lost on process restart (not persistent)
 * - Memory usage grows unbounded without cleanup
 * - Not suitable for production use
 */
export class InMemoryEventStore implements EventStore {
  /** Events grouped by submission ID, ordered chronologically */
  private readonly eventsBySubmission: Map<string, IntakeEvent[]> = new Map();

  /** Set of all event IDs for duplicate detection */
  private readonly eventIds: Set<string> = new Set();

  /** Monotonically increasing version counter per submission */
  private readonly versionCounters: Map<string, number> = new Map();

  /**
   * Append a new event to the store.
   *
   * The event must have a unique eventId. Duplicate eventIds will throw an error.
   * Events are stored in chronological order by timestamp.
   *
   * @param event The event to append
   * @throws Error if eventId is duplicate or event is invalid
   */
  async appendEvent(event: IntakeEvent): Promise<void> {
    // Validate event has required fields
    if (!event.eventId) {
      throw new Error('Event must have eventId');
    }
    if (!event.submissionId) {
      throw new Error('Event must have submissionId');
    }
    if (!event.ts) {
      throw new Error('Event must have timestamp (ts)');
    }

    // Check for duplicate eventId
    if (this.eventIds.has(event.eventId)) {
      throw new Error(`Duplicate eventId: ${event.eventId}`);
    }

    // Get or create event array for this submission
    let events = this.eventsBySubmission.get(event.submissionId);
    if (!events) {
      events = [];
      this.eventsBySubmission.set(event.submissionId, events);
    }

    // Auto-assign monotonically increasing version per submission
    const currentVersion = this.versionCounters.get(event.submissionId) ?? 0;
    const nextVersion = currentVersion + 1;
    event.version = nextVersion;
    this.versionCounters.set(event.submissionId, nextVersion);

    // Append event (events are already ordered by timestamp in practice)
    events.push(event);
    this.eventIds.add(event.eventId);

    // Sort to maintain chronological order (defensive - handles out-of-order appends)
    events.sort((a, b) => a.ts.localeCompare(b.ts));
  }

  /**
   * Get all events for a submission, optionally filtered.
   *
   * Events are returned in chronological order (oldest first).
   * All filters are optional and can be combined:
   * - types: Include only events with these types
   * - actorKind: Include only events from this actor kind
   * - since: Include only events at or after this timestamp (inclusive)
   * - until: Include only events at or before this timestamp (inclusive)
   *
   * @param submissionId The submission ID to query
   * @param filters Optional filters to narrow results
   * @returns Array of events matching the query (empty if submission not found)
   */
  async getEvents(
    submissionId: string,
    filters?: EventFilters
  ): Promise<IntakeEvent[]> {
    const events = this.eventsBySubmission.get(submissionId) ?? [];

    // Return all events if no filters
    if (!filters) {
      return [...events]; // Return copy to prevent external modification
    }

    // Apply content filters
    let filtered = events.filter((event) => {
      // Filter by event types
      if (filters.types && filters.types.length > 0) {
        if (!filters.types.includes(event.type)) {
          return false;
        }
      }

      // Filter by actor kind
      if (filters.actorKind && event.actor.kind !== filters.actorKind) {
        return false;
      }

      // Filter by time range (since)
      if (filters.since && event.ts < filters.since) {
        return false;
      }

      // Filter by time range (until)
      if (filters.until && event.ts > filters.until) {
        return false;
      }

      return true;
    });

    // Apply pagination
    const offset = filters.offset ?? 0;
    if (offset > 0) {
      filtered = filtered.slice(offset);
    }
    if (filters.limit !== undefined && filters.limit >= 0) {
      filtered = filtered.slice(0, filters.limit);
    }

    return filtered;
  }

  /**
   * Get store statistics.
   *
   * Calculates:
   * - Total number of events across all submissions
   * - Number of unique submissions with events
   * - Oldest event timestamp (if any events exist)
   * - Newest event timestamp (if any events exist)
   *
   * @returns Statistics about the event store
   */
  async getStats(): Promise<EventStoreStats> {
    let totalEvents = 0;
    let oldestTs: string | undefined;
    let newestTs: string | undefined;

    // Iterate through all submissions and their events
    for (const events of this.eventsBySubmission.values()) {
      totalEvents += events.length;

      if (events.length > 0) {
        // First event is oldest (sorted chronologically)
        const firstTs = events[0]!.ts;
        if (!oldestTs || firstTs < oldestTs) {
          oldestTs = firstTs;
        }

        // Last event is newest (sorted chronologically)
        const lastTs = events[events.length - 1]!.ts;
        if (!newestTs || lastTs > newestTs) {
          newestTs = lastTs;
        }
      }
    }

    return {
      totalEvents,
      submissionCount: this.eventsBySubmission.size,
      oldestEvent: oldestTs,
      newestEvent: newestTs,
    };
  }

  /**
   * Clean up old events for storage maintenance.
   *
   * Removes events older than the specified age.
   * If a submission has no events after cleanup, it is removed entirely.
   *
   * Use cases:
   * - Testing cleanup between test runs
   * - Development environment maintenance
   * - Simulating retention policies
   *
   * @param olderThanMs Age threshold in milliseconds (events older than this are deleted)
   * @returns Number of events deleted
   */
  async cleanupOld(olderThanMs: number): Promise<number> {
    const cutoffTime = new Date(Date.now() - olderThanMs).toISOString();
    let deletedCount = 0;

    // Iterate through all submissions
    for (const [submissionId, events] of this.eventsBySubmission.entries()) {
      // Filter out old events
      const retainedEvents = events.filter((event) => {
        const shouldDelete = event.ts < cutoffTime;
        if (shouldDelete) {
          this.eventIds.delete(event.eventId);
          deletedCount++;
        }
        return !shouldDelete;
      });

      // Update or remove the submission's event array
      if (retainedEvents.length === 0) {
        this.eventsBySubmission.delete(submissionId);
        this.versionCounters.delete(submissionId);
      } else if (retainedEvents.length < events.length) {
        this.eventsBySubmission.set(submissionId, retainedEvents);
      }
    }

    return deletedCount;
  }
}
